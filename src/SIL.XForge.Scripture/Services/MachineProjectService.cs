using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Microsoft.FeatureManagement;
using Newtonsoft.Json.Linq;
using Serval.Client;
using SIL.Scripture;
using SIL.XForge.Configuration;
using SIL.XForge.DataAccess;
using SIL.XForge.Models;
using SIL.XForge.Realtime;
using SIL.XForge.Realtime.Json0;
using SIL.XForge.Scripture.Models;
using SIL.XForge.Services;
using SIL.XForge.Utils;

// Disable notice "The logging message template should not vary between calls to..."
#pragma warning disable CA2254

namespace SIL.XForge.Scripture.Services;

/// <summary>
/// Provides functionality to add, remove, and build Machine projects.
/// </summary>
public class MachineProjectService(
    ICorporaClient corporaClient,
    IDataFilesClient dataFilesClient,
    IExceptionHandler exceptionHandler,
    IFeatureManager featureManager,
    IFileSystemService fileSystemService,
    ILogger<MachineProjectService> logger,
    IParatextService paratextService,
    IRepository<SFProjectSecret> projectSecrets,
    IRealtimeService realtimeService,
    IOptions<SiteOptions> siteOptions,
    ITrainingDataService trainingDataService,
    ITranslationEnginesClient translationEnginesClient,
    IRepository<UserSecret> userSecrets
) : IMachineProjectService
{
    // Supported translation engines (Serval 1.2 format)
    // Serval 1.2 accepts the translation engine type in 1.1 (PascalCase) and 1.2 (kebab-case) format
    internal const string Echo = "echo";
    internal const string Nmt = "nmt";
    internal const string SmtTransfer = "smt-transfer";

    /// <summary>
    /// Adds the project to Serval, if the required data is present.
    /// </summary>
    /// <param name="sfProjectId">The Scripture Forge project identifier.</param>
    /// <param name="preTranslate">If <c>true</c> use NMT; otherwise if <c>false</c> use SMT.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>The translation engine identifier.</returns>
    /// <exception cref="DataNotFoundException">The project does not exist.</exception>
    public async Task<string> AddProjectAsync(
        string sfProjectId,
        bool preTranslate,
        CancellationToken cancellationToken
    )
    {
        // Load the project from the realtime service
        Attempt<SFProject> attempt = await realtimeService.TryGetSnapshotAsync<SFProject>(sfProjectId);
        if (!attempt.TryResult(out SFProject project))
        {
            throw new DataNotFoundException("The project does not exist.");
        }

        // We may not have the source language tag or target language tag if either is a back translation
        // If that is the case, we will create the translation engine on first sync by running this method again
        // After ensuring that the source and target language tags are present
        if (
            !string.IsNullOrWhiteSpace(project.TranslateConfig.Source?.WritingSystem.Tag)
            && !string.IsNullOrWhiteSpace(project.WritingSystem.Tag)
        )
        {
            return await CreateServalProjectAsync(project, preTranslate, cancellationToken);
        }

        logger.LogInformation("The source or target language is missing from the project");
        return string.Empty;
    }

    /// <summary>
    /// Executes <see cref="BuildProjectAsync"/>, and traps any errors during execution.
    /// </summary>
    /// <param name="userAccessor">An IUserAccessor for the acting user.</param>
    /// <param name="buildConfig">The build configuration.</param>
    /// <param name="preTranslate">If <c>true</c> use NMT; otherwise if <c>false</c> use SMT.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>An asynchronous task.</returns>
    /// <remarks>
    /// This cannot be run multiple times in different threads.
    /// </remarks>
    [Mutex]
    public async Task BuildProjectForBackgroundJobAsync(
        IUserAccessor userAccessor,
        BuildConfig buildConfig,
        bool preTranslate,
        CancellationToken cancellationToken
    )
    {
        try
        {
            await BuildProjectAsync(userAccessor, buildConfig, preTranslate, cancellationToken);
        }
        catch (TaskCanceledException e) when (e.InnerException is not TimeoutException)
        {
            // Do not log error - the job was cancelled
            // Exclude TaskCanceledException with an inner TimeoutException, as this generated by an HttpClient timeout

            // Ensure that the queued at timestamp is not present
            await projectSecrets.UpdateAsync(
                buildConfig.ProjectId,
                u =>
                {
                    if (preTranslate)
                    {
                        u.Unset(p => p.ServalData.PreTranslationQueuedAt);
                    }
                    else
                    {
                        u.Unset(p => p.ServalData.TranslationQueuedAt);
                    }
                }
            );
        }
        catch (ServalApiException e) when (e.StatusCode == 409)
        {
            // A build is already in progress - clear the job details and don't record the error
            await projectSecrets.UpdateAsync(
                buildConfig.ProjectId,
                u =>
                {
                    if (preTranslate)
                    {
                        u.Unset(p => p.ServalData.PreTranslationJobId);
                        u.Unset(p => p.ServalData.PreTranslationQueuedAt);
                    }
                    else
                    {
                        u.Unset(p => p.ServalData.TranslationJobId);
                        u.Unset(p => p.ServalData.TranslationQueuedAt);
                    }
                }
            );
        }
        catch (DataNotFoundException e)
        {
            // This will occur if the project is deleted while the job is running
            string message =
                $"Build DataNotFoundException occurred for project {buildConfig.ProjectId.Sanitize()}"
                + " running in background job.";
            logger.LogWarning(e, message);
        }
        catch (Exception e)
        {
            // Log the error and report to bugsnag
            string message =
                $"Build exception occurred for project {buildConfig.ProjectId.Sanitize()}"
                + " running in background job.";
            logger.LogError(e, message);
            exceptionHandler.ReportException(e);

            // Update the project secret with the error message
            await projectSecrets.UpdateAsync(
                buildConfig.ProjectId,
                u =>
                {
                    if (preTranslate)
                    {
                        u.Set(p => p.ServalData.PreTranslationErrorMessage, e.Message);
                        u.Unset(p => p.ServalData.PreTranslationJobId);
                        u.Unset(p => p.ServalData.PreTranslationQueuedAt);
                    }
                    else
                    {
                        u.Set(p => p.ServalData.TranslationErrorMessage, e.Message);
                        u.Unset(p => p.ServalData.TranslationJobId);
                        u.Unset(p => p.ServalData.TranslationQueuedAt);
                    }
                }
            );
        }
    }

    /// <summary>
    /// Gets the project as a zip file, writing it to <paramref name="outputStream"/>.
    /// </summary>
    /// <param name="sfProjectId">The Scripture Forge project identifier.</param>
    /// <param name="outputStream">The output stream.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>The name of the zip file, e.g. <c>ABC.zip</c>.</returns>
    /// <exception cref="DataNotFoundException">
    /// The project does not exist, is a resource, or could not be found on disk.
    /// </exception>
    public async Task<string> GetProjectZipAsync(
        string sfProjectId,
        Stream outputStream,
        CancellationToken cancellationToken
    )
    {
        // Load the project from the realtime service
        Attempt<SFProject> attempt = await realtimeService.TryGetSnapshotAsync<SFProject>(sfProjectId);
        if (!attempt.TryResult(out SFProject project))
        {
            throw new DataNotFoundException("The project does not exist.");
        }

        // Ensure that the project is not a resource
        if (paratextService.IsResource(project.ParatextId))
        {
            throw new DataNotFoundException("You cannot download a resource.");
        }

        // Create the zip file from the directory in memory
        await CreateZipFileFromParatextDirectoryAsync(project.ParatextId, outputStream, cancellationToken);

        // Strip invalid characters from the file name
        string fileName = Path.GetInvalidFileNameChars()
            .Aggregate(project.ShortName, (current, c) => current.Replace(c.ToString(), string.Empty));
        return $"{fileName}.zip";
    }

    /// <summary>
    /// Gets the translation engine type string for Serval.
    /// </summary>
    /// <param name="preTranslate">If <c>true</c> use NMT; otherwise if <c>false</c> use SMT.</param>
    /// <returns>The translation engine type string for Serval.</returns>
    public async Task<string> GetTranslationEngineTypeAsync(bool preTranslate)
    {
        bool useEcho = await featureManager.IsEnabledAsync(FeatureFlags.UseEchoForPreTranslation);
        return preTranslate switch
        {
            true when useEcho => Echo,
            true => Nmt,
            false => SmtTransfer,
        };
    }

    /// <summary>
    /// Removes a project from Serval.
    /// </summary>
    /// <param name="sfProjectId">The Scripture Forge project identifier.</param>
    /// <param name="preTranslate">If <c>true</c> use NMT; otherwise if <c>false</c> use SMT.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>An asynchronous task.</returns>
    /// <exception cref="DataNotFoundException">The project secret cannot be found.</exception>
    /// <remarks>This can be mocked in unit tests.</remarks>
    public virtual async Task RemoveProjectAsync(
        string sfProjectId,
        bool preTranslate,
        CancellationToken cancellationToken
    )
    {
        // Load the target project secrets, so we can get the translation engine ID
        if (!(await projectSecrets.TryGetAsync(sfProjectId)).TryResult(out SFProjectSecret projectSecret))
        {
            throw new DataNotFoundException("The project secret cannot be found.");
        }

        // Ensure we have a translation engine id
        string translationEngineId = GetTranslationEngineId(projectSecret, preTranslate);
        if (string.IsNullOrWhiteSpace(translationEngineId))
        {
            logger.LogInformation($"No Translation Engine Id specified for project {sfProjectId.Sanitize()}");
            return;
        }

        // Remove the legacy serval data
        await RemoveLegacyServalDataAsync(sfProjectId, preTranslate, cancellationToken);

        // Build the list of files, corpora, and parallel corpora to remove
        List<string?> fileIdsToRemove = [];
        List<string?> corpusIdsToRemove = [];
        if (preTranslate)
        {
            // Remove the additional training data
            if (projectSecret.ServalData?.AdditionalTrainingData is not null)
            {
                corpusIdsToRemove.Add(projectSecret.ServalData.AdditionalTrainingData.SourceCorpusId);
                corpusIdsToRemove.Add(projectSecret.ServalData.AdditionalTrainingData.TargetCorpusId);
                fileIdsToRemove.AddRange(
                    projectSecret.ServalData.AdditionalTrainingData.CorpusFiles.Select(f => f.FileId)
                );
            }

            // If there is no SMT training engine, remove all files and corpora
            if (
                projectSecret.ServalData is not null
                && string.IsNullOrWhiteSpace(projectSecret.ServalData.TranslationEngineId)
            )
            {
                corpusIdsToRemove.AddRange(projectSecret.ServalData.CorpusFiles.Select(f => f.CorpusId));
                fileIdsToRemove.AddRange(projectSecret.ServalData.CorpusFiles.Select(f => f.FileId));
            }
        }
        else if (
            projectSecret.ServalData is not null
            && string.IsNullOrWhiteSpace(projectSecret.ServalData.PreTranslationEngineId)
        )
        {
            // If there is no NMT training engine, remove all files and corpora
            corpusIdsToRemove.AddRange(projectSecret.ServalData.CorpusFiles.Select(f => f.CorpusId));
            fileIdsToRemove.AddRange(projectSecret.ServalData.CorpusFiles.Select(f => f.FileId));
        }

        // Remove the specified corpora
        foreach (string corpusId in corpusIdsToRemove.Where(s => !string.IsNullOrWhiteSpace(s)))
        {
            try
            {
                await corporaClient.DeleteAsync(corpusId, cancellationToken);
            }
            catch (ServalApiException e) when (e.StatusCode == StatusCodes.Status404NotFound)
            {
                // If the file was already deleted, just log a message
                string message =
                    $"Corpus {corpusId.Sanitize()} in project {sfProjectId.Sanitize()}"
                    + " was missing or already deleted.";
                logger.LogInformation(e, message);
            }
        }

        // Remove the specified files
        foreach (string fileId in fileIdsToRemove.Where(s => !string.IsNullOrWhiteSpace(s)))
        {
            try
            {
                await dataFilesClient.DeleteAsync(fileId, cancellationToken);
            }
            catch (ServalApiException e) when (e.StatusCode == StatusCodes.Status404NotFound)
            {
                // If the file was already deleted, just log a message
                string message =
                    $"File {fileId.Sanitize()} in project {sfProjectId.Sanitize()}"
                    + " was missing or already deleted.";
                logger.LogInformation(e, message);
            }
        }

        // Remove the project from Serval
        try
        {
            await translationEnginesClient.DeleteAsync(translationEngineId, cancellationToken);
        }
        catch (ServalApiException e) when (e.StatusCode == StatusCodes.Status404NotFound)
        {
            // If the file was already deleted, just log a message
            string message =
                $"Translation Engine {translationEngineId.Sanitize()} in project {sfProjectId.Sanitize()}"
                + " was missing or already deleted.";
            logger.LogInformation(e, message);
        }

        // Remove the translation engine identifier, and other related information
        await projectSecrets.UpdateAsync(
            sfProjectId,
            u =>
            {
                if (preTranslate)
                {
                    u.Unset(p => p.ServalData.PreTranslationEngineId);
                    u.Unset(p => p.ServalData.ParallelCorpusIdForPreTranslate);
                    u.Unset(p => p.ServalData.ParallelCorpusIdForTrainOn);
                    u.Unset(p => p.ServalData.PreTranslationsRetrieved);
                    u.Unset(p => p.ServalData.AdditionalTrainingData);
                }
                else
                {
                    u.Unset(p => p.ServalData.TranslationEngineId);
                    u.Unset(p => p.ServalData.ParallelCorpusIdForSmt);
                }

                // Remove all corpora that were deleted
                u.RemoveAll(p => p.ServalData.CorpusFiles, p => corpusIdsToRemove.Contains(p.CorpusId));
            }
        );
    }

    /// <summary>
    /// Updates the language configuration for the additional and alternate sources.
    /// </summary>
    /// <param name="curUserId">The current user identifier.</param>
    /// <param name="sfProjectId">The Scripture Forge project identifier.</param>
    /// <returns></returns>
    /// <exception cref="DataNotFoundException">The project or user secret does not exist.</exception>
    [Mutex]
    public async Task UpdateTranslationSourcesAsync(string curUserId, string sfProjectId)
    {
        // Get the user secret
        if (!(await userSecrets.TryGetAsync(curUserId)).TryResult(out UserSecret userSecret))
        {
            throw new DataNotFoundException("The user secret does not exist.");
        }

        // Load the project from the realtime service
        await using IConnection conn = await realtimeService.ConnectAsync(curUserId);
        IDocument<SFProject> projectDoc = await conn.FetchAsync<SFProject>(sfProjectId);
        if (!projectDoc.IsLoaded)
        {
            throw new DataNotFoundException("The project does not exist.");
        }

        // If there is an alternate source, ensure that name, writing system and RTL is correct
        if (projectDoc.Data.TranslateConfig.DraftConfig.AlternateSource is not null)
        {
            ParatextSettings? alternateSourceSettings = paratextService.GetParatextSettings(
                userSecret,
                projectDoc.Data.TranslateConfig.DraftConfig.AlternateSource.ParatextId
            );
            if (alternateSourceSettings is not null)
            {
                await projectDoc.SubmitJson0OpAsync(op =>
                {
                    op.Set(
                        pd => pd.TranslateConfig.DraftConfig.AlternateSource.IsRightToLeft,
                        alternateSourceSettings.IsRightToLeft
                    );
                    if (alternateSourceSettings.LanguageTag is not null)
                    {
                        op.Set(
                            pd => pd.TranslateConfig.DraftConfig.AlternateSource.WritingSystem.Tag,
                            alternateSourceSettings.LanguageTag
                        );
                    }
                    if (alternateSourceSettings.FullName is not null)
                    {
                        op.Set(
                            pd => pd.TranslateConfig.DraftConfig.AlternateSource.Name,
                            alternateSourceSettings.FullName
                        );
                    }
                });
            }
        }

        // If there is an alternate training source, ensure that name, writing system and RTL is correct
        if (projectDoc.Data.TranslateConfig.DraftConfig.AlternateTrainingSource is not null)
        {
            ParatextSettings? alternateTrainingSourceSettings = paratextService.GetParatextSettings(
                userSecret,
                projectDoc.Data.TranslateConfig.DraftConfig.AlternateTrainingSource.ParatextId
            );
            if (alternateTrainingSourceSettings is not null)
            {
                await projectDoc.SubmitJson0OpAsync(op =>
                {
                    op.Set(
                        pd => pd.TranslateConfig.DraftConfig.AlternateTrainingSource.IsRightToLeft,
                        alternateTrainingSourceSettings.IsRightToLeft
                    );
                    if (alternateTrainingSourceSettings.LanguageTag is not null)
                    {
                        op.Set(
                            pd => pd.TranslateConfig.DraftConfig.AlternateTrainingSource.WritingSystem.Tag,
                            alternateTrainingSourceSettings.LanguageTag
                        );
                    }
                    if (alternateTrainingSourceSettings.FullName is not null)
                    {
                        op.Set(
                            pd => pd.TranslateConfig.DraftConfig.AlternateTrainingSource.Name,
                            alternateTrainingSourceSettings.FullName
                        );
                    }
                });
            }
        }

        // If there is an additional training source, ensure that name, writing system and RTL is correct
        if (projectDoc.Data.TranslateConfig.DraftConfig.AdditionalTrainingSource is not null)
        {
            ParatextSettings? additionalTrainingSourceSettings = paratextService.GetParatextSettings(
                userSecret,
                projectDoc.Data.TranslateConfig.DraftConfig.AdditionalTrainingSource.ParatextId
            );
            if (additionalTrainingSourceSettings is not null)
            {
                await projectDoc.SubmitJson0OpAsync(op =>
                {
                    op.Set(
                        pd => pd.TranslateConfig.DraftConfig.AdditionalTrainingSource.IsRightToLeft,
                        additionalTrainingSourceSettings.IsRightToLeft
                    );
                    if (additionalTrainingSourceSettings.LanguageTag is not null)
                    {
                        op.Set(
                            pd => pd.TranslateConfig.DraftConfig.AdditionalTrainingSource.WritingSystem.Tag,
                            additionalTrainingSourceSettings.LanguageTag
                        );
                    }
                    if (additionalTrainingSourceSettings.FullName is not null)
                    {
                        op.Set(
                            pd => pd.TranslateConfig.DraftConfig.AdditionalTrainingSource.Name,
                            additionalTrainingSourceSettings.FullName
                        );
                    }
                });
            }
        }
    }

    /// <summary>
    /// Builds a project on Serval, including syncing and any required setup.
    /// </summary>
    /// <param name="userAccessor">An IUserAccessor for the acting user.</param>
    /// <param name="buildConfig">The build configuration.</param>
    /// <param name="preTranslate">If <c>true</c> use NMT; otherwise if <c>false</c> use SMT.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>An asynchronous task.</returns>
    /// <exception cref="DataNotFoundException">The project or project secret could not be found.</exception>
    /// <remarks>This can be mocked in unit tests.</remarks>
    protected internal virtual async Task BuildProjectAsync(
        IUserAccessor userAccessor,
        BuildConfig buildConfig,
        bool preTranslate,
        CancellationToken cancellationToken
    )
    {
        // Load the target project secrets, so we can get the translation engine ID
        if (!(await projectSecrets.TryGetAsync(buildConfig.ProjectId)).TryResult(out SFProjectSecret projectSecret))
        {
            throw new DataNotFoundException("The project secret cannot be found.");
        }

        // Load the project from the realtime service
        await using IConnection conn = await realtimeService.ConnectAsync(userAccessor.UserId);
        IDocument<SFProject> projectDoc = await conn.FetchAsync<SFProject>(buildConfig.ProjectId);
        if (!projectDoc.IsLoaded)
        {
            throw new DataNotFoundException("The project does not exist.");
        }

        // Remove the legacy serval data, if present
        await RemoveLegacyServalDataAsync(buildConfig.ProjectId, preTranslate, cancellationToken);

        // Ensure we have a translation engine id or a pre-translation engine id, and that it exists
        string translationEngineId = await EnsureTranslationEngineExistsAsync(
            userAccessor.UserId,
            projectDoc,
            projectSecret,
            preTranslate,
            cancellationToken
        );

        // Recreate the translation engine if it is missing, or the language has changed
        await RecreateTranslationEngineIfRequiredAsync(
            translationEngineId,
            projectDoc.Data,
            preTranslate,
            cancellationToken
        );

        // Perform the file and corpora sync with Serval
        IList<ServalCorpusSyncInfo> corporaSyncInfo = await SyncProjectCorporaAsync(
            userAccessor,
            buildConfig,
            preTranslate,
            cancellationToken
        );

        // Get the updated project secret
        projectSecret = await projectSecrets.GetAsync(buildConfig.ProjectId);

        // Ensure we have the ServalData
        if (projectSecret.ServalData is null)
        {
            throw new DataNotFoundException("The project secret does not contain Serval data.");
        }

        // Set up the Serval Configuration
        string? servalConfig = null;
        if (projectDoc.Data.TranslateConfig.DraftConfig.ServalConfig is not null)
        {
            // Load the Serval Config from the Draft Config
            servalConfig = projectDoc.Data.TranslateConfig.DraftConfig.ServalConfig;
        }

        // Get the appropriate translation engine
        TranslationBuildConfig translationBuildConfig;
        if (preTranslate)
        {
            translationEngineId = projectSecret.ServalData.PreTranslationEngineId!;

            // Execute a complete pre-translation
            translationBuildConfig = GetTranslationBuildConfig(
                projectSecret.ServalData,
                servalConfig,
                buildConfig,
                corporaSyncInfo
            );
        }
        else
        {
            translationEngineId = projectSecret.ServalData.TranslationEngineId!;
            translationBuildConfig = new TranslationBuildConfig();
        }

        // Start the build
        await translationEnginesClient.StartBuildAsync(translationEngineId, translationBuildConfig, cancellationToken);

        // Clear the queued status and job id
        await projectSecrets.UpdateAsync(
            buildConfig.ProjectId,
            u =>
            {
                if (preTranslate)
                {
                    u.Unset(p => p.ServalData.PreTranslationJobId);
                    u.Unset(p => p.ServalData.PreTranslationQueuedAt);
                }
                else
                {
                    u.Unset(p => p.ServalData.TranslationJobId);
                    u.Unset(p => p.ServalData.TranslationQueuedAt);
                }
            }
        );
    }

    /// <summary>
    /// Creates or Updates a Parallel Corpus on Serval.
    /// </summary>
    /// <param name="translationEngineId">The translation engine identifier.</param>
    /// <param name="parallelCorpusId">
    /// The parallel corpus to be updated. If <c>null</c> or empty, a new parallel corpus will be created.
    /// </param>
    /// <param name="name">
    /// The name of the parallel corpus. This will only be used if the parallel corpus is being created.
    /// </param>
    /// <param name="sourceCorpusIds">The source corpus identifiers.</param>
    /// <param name="targetCorpusIds">The target corpus identifiers.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>
    /// The new or updated parallel corpus identifier. If <paramref name="parallelCorpusId"/> is not <c>null</c>,
    /// this will be the same value as <paramref name="parallelCorpusId"/>. If <paramref name="parallelCorpusId"/>
    /// is <c>null</c>, this will be the identifier of the new parallel corpus.
    /// </returns>
    /// <remarks>This can be mocked in unit tests.</remarks>
    protected internal virtual async Task<string> CreateOrUpdateParallelCorpusAsync(
        string translationEngineId,
        string? parallelCorpusId,
        string? name,
        IList<string> sourceCorpusIds,
        IList<string> targetCorpusIds,
        CancellationToken cancellationToken
    )
    {
        // Check that the parallel corpus exists on Serval, and that we have access to it
        if (!string.IsNullOrWhiteSpace(parallelCorpusId))
        {
            try
            {
                TranslationParallelCorpus parallelCorpus = await translationEnginesClient.GetParallelCorpusAsync(
                    translationEngineId,
                    parallelCorpusId,
                    cancellationToken
                );
                parallelCorpusId = parallelCorpus.Id;
            }
            catch (ServalApiException e) when (e.StatusCode == StatusCodes.Status404NotFound)
            {
                // The parallel corpus does not exist or is inaccessible
                parallelCorpusId = null;
            }
        }

        if (string.IsNullOrWhiteSpace(parallelCorpusId))
        {
            // Create a new parallel corpus
            TranslationParallelCorpus parallelCorpus = await translationEnginesClient.AddParallelCorpusAsync(
                translationEngineId,
                new TranslationParallelCorpusConfig
                {
                    Name = name,
                    SourceCorpusIds = sourceCorpusIds,
                    TargetCorpusIds = targetCorpusIds,
                },
                cancellationToken
            );
            parallelCorpusId = parallelCorpus.Id;
        }
        else
        {
            // Update the specified parallel corpus
            await translationEnginesClient.UpdateParallelCorpusAsync(
                translationEngineId,
                parallelCorpusId,
                new TranslationParallelCorpusUpdateConfig
                {
                    SourceCorpusIds = sourceCorpusIds,
                    TargetCorpusIds = targetCorpusIds,
                },
                cancellationToken
            );
        }

        return parallelCorpusId;
    }

    /// <summary>
    /// Creates the translation engine for a project in Serval,
    /// and updates the project secret with the translation engine identifier.
    /// </summary>
    /// <param name="sfProject">The Scripture Forge project</param>
    /// <param name="preTranslate">If <c>true</c> use NMT; otherwise if <c>false</c> use SMT.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>The translation engine id.</returns>
    /// <exception cref="DataNotFoundException">The translation engine could not be created.</exception>
    /// <remarks>This can be mocked in unit tests.</remarks>
    protected internal virtual async Task<string> CreateServalProjectAsync(
        SFProject sfProject,
        bool preTranslate,
        CancellationToken cancellationToken
    )
    {
        // Get the existing project secret, so we can see how to create the engine and update the Serval data
        SFProjectSecret projectSecret = await projectSecrets.GetAsync(sfProject.Id);
        string translationEngineId = GetTranslationEngineId(projectSecret, preTranslate);
        if (string.IsNullOrWhiteSpace(translationEngineId))
        {
            TranslationEngineConfig engineConfig = new TranslationEngineConfig
            {
                Name = sfProject.Id,
                SourceLanguage = GetSourceLanguage(sfProject),
                TargetLanguage = await GetTargetLanguageAsync(sfProject),
                Type = await GetTranslationEngineTypeAsync(preTranslate),
            };

            // Add the project to Serval
            TranslationEngine translationEngine = await translationEnginesClient.CreateAsync(
                engineConfig,
                cancellationToken
            );
            if (string.IsNullOrWhiteSpace(translationEngine.Id))
            {
                throw new DataNotFoundException("Translation Engine ID from Serval is missing.");
            }

            // Get the new translation engine id
            translationEngineId = translationEngine.Id;

            if (projectSecret.ServalData is not null && preTranslate)
            {
                // Store the Pre-Translation Engine ID
                await projectSecrets.UpdateAsync(
                    sfProject.Id,
                    u => u.Set(p => p.ServalData.PreTranslationEngineId, translationEngineId)
                );
            }
            else if (projectSecret.ServalData is not null)
            {
                // Store the Translation Engine ID
                await projectSecrets.UpdateAsync(
                    sfProject.Id,
                    u => u.Set(p => p.ServalData.TranslationEngineId, translationEngineId)
                );
            }
            else if (preTranslate)
            {
                // Store the Pre-Translation Engine ID
                await projectSecrets.UpdateAsync(
                    sfProject.Id,
                    u =>
                        u.Set(
                            p => p.ServalData,
                            new ServalData { PreTranslationEngineId = translationEngineId, CorpusFiles = [] }
                        )
                );
            }
            else
            {
                // Store the Translation Engine ID
                await projectSecrets.UpdateAsync(
                    sfProject.Id,
                    u =>
                        u.Set(
                            p => p.ServalData,
                            new ServalData { TranslationEngineId = translationEngineId, CorpusFiles = [] }
                        )
                );
            }
        }

        return translationEngineId;
    }

    /// <summary>
    /// Creates a zip file from the contents of a directory.
    /// </summary>
    /// <param name="paratextId">The Paratext identifier for the project.</param>
    /// <param name="outputStream">The output stream.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>An asynchronous task.</returns>
    /// <remarks>This can be mocked in unit tests.</remarks>
    protected internal virtual async Task CreateZipFileFromParatextDirectoryAsync(
        string paratextId,
        Stream outputStream,
        CancellationToken cancellationToken
    )
    {
        // Get the path to the Paratext directory
        string path = Path.Combine(siteOptions.Value.SiteDir, "sync", paratextId, "target");

        // Ensure that the path exists
        if (!fileSystemService.DirectoryExists(path))
        {
            throw new DataNotFoundException($"The directory could not be found for {paratextId}");
        }

        using var archive = new ZipArchive(outputStream, ZipArchiveMode.Create, leaveOpen: true);
        foreach (string filePath in fileSystemService.EnumerateFiles(path))
        {
            await using Stream fileStream = fileSystemService.OpenFile(filePath, FileMode.Open);
            ZipArchiveEntry entry = archive.CreateEntry(Path.GetFileName(filePath));
            await using Stream entryStream = entry.Open();
            await fileStream.CopyToAsync(entryStream, cancellationToken);
        }
    }

    /// <summary>
    /// Deletes all corpora and files for the specified <see cref="ServalCorpusFile"/> collection.
    /// </summary>
    /// <param name="servalCorpusFiles">The Serval Corpus Files.</param>
    /// <param name="projectId">The project identifier</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <remarks>This can be mocked in unit tests.</remarks>
    protected internal virtual async Task DeleteAllCorporaAndFilesAsync(
        IEnumerable<ServalCorpusFile> servalCorpusFiles,
        string projectId,
        CancellationToken cancellationToken
    )
    {
        foreach (ServalCorpusFile servalCorpusFile in servalCorpusFiles)
        {
            try
            {
                await corporaClient.DeleteAsync(servalCorpusFile.CorpusId, cancellationToken);
            }
            catch (ServalApiException e) when (e.StatusCode == StatusCodes.Status404NotFound)
            {
                // If the file was already deleted, just log a message
                string message =
                    $"Corpus {servalCorpusFile.CorpusId.Sanitize()} in project {projectId.Sanitize()}"
                    + " was missing or already deleted.";
                logger.LogInformation(e, message);
            }

            try
            {
                await dataFilesClient.DeleteAsync(servalCorpusFile.FileId, cancellationToken);
            }
            catch (ServalApiException e) when (e.StatusCode == StatusCodes.Status404NotFound)
            {
                // If the file was already deleted, just log a message
                string message =
                    $"File {servalCorpusFile.FileId.Sanitize()} in project {projectId.Sanitize()}"
                    + " was missing or already deleted.";
                logger.LogInformation(e, message);
            }
        }
    }

    /// <summary>
    /// Ensures that the translation engine exists, and that the Scripture Forge project is in a compatible state.
    /// </summary>
    /// <param name="curUserId">The current user identifier.</param>
    /// <param name="projectDoc">The project document.</param>
    /// <param name="projectSecret">The project secret.</param>
    /// <param name="preTranslate">If <c>true</c> use NMT; otherwise if <c>false</c> use SMT.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>The translation engine identifier.</returns>
    /// <exception cref="DataNotFoundException">The project, user, or translation engine does not exist.</exception>
    /// <remarks>This can be mocked in unit tests.</remarks>
    protected internal virtual async Task<string> EnsureTranslationEngineExistsAsync(
        string curUserId,
        IDocument<SFProject> projectDoc,
        SFProjectSecret projectSecret,
        bool preTranslate,
        CancellationToken cancellationToken
    )
    {
        string translationEngineId = GetTranslationEngineId(projectSecret, preTranslate);
        if (!await TranslationEngineExistsAsync(projectDoc.Id, translationEngineId, preTranslate, cancellationToken))
        {
            // We do not have one, likely because the translation is a back translation
            // We can only get the language tags for back translations from the ScrText,
            // which is not present until after the first sync (not from the Registry).

            // If the source or target writing system tag is missing, get them from the ScrText
            // We do not need to do this for the alternate source as this would have been populated correctly
            if (
                string.IsNullOrWhiteSpace(projectDoc.Data?.WritingSystem.Tag)
                || string.IsNullOrWhiteSpace(projectDoc.Data?.TranslateConfig.Source?.WritingSystem.Tag)
            )
            {
                // Get the user secret
                Attempt<UserSecret> userSecretAttempt = await userSecrets.TryGetAsync(curUserId);
                if (!userSecretAttempt.TryResult(out UserSecret userSecret))
                {
                    throw new DataNotFoundException("The user does not exist.");
                }

                // This error can occur if the project is deleted while the build is running
                if (projectDoc.Data is null)
                {
                    throw new DataNotFoundException("The project does not exist.");
                }

                // Update the target writing system tag
                if (string.IsNullOrWhiteSpace(projectDoc.Data.WritingSystem.Tag))
                {
                    WritingSystem writingSystem = paratextService.GetWritingSystem(
                        userSecret,
                        projectDoc.Data.ParatextId
                    );
                    if (!string.IsNullOrEmpty(writingSystem.Tag))
                    {
                        await projectDoc.SubmitJson0OpAsync(op =>
                        {
                            op.Set(p => p.WritingSystem.Region, writingSystem.Region);
                            op.Set(p => p.WritingSystem.Script, writingSystem.Script);
                            op.Set(p => p.WritingSystem.Tag, writingSystem.Tag);
                        });
                    }
                }

                // This error can occur if the project is deleted while the build is running
                if (projectDoc.Data is null)
                {
                    throw new DataNotFoundException("The project does not exist.");
                }

                // This error can occur if the project source is cleared while the build is running
                if (projectDoc.Data.TranslateConfig.Source is null)
                {
                    throw new DataNotFoundException("The project source is not specified.");
                }

                // Update the source writing system tag
                if (string.IsNullOrWhiteSpace(projectDoc.Data.TranslateConfig.Source.WritingSystem.Tag))
                {
                    WritingSystem writingSystem = paratextService.GetWritingSystem(
                        userSecret,
                        projectDoc.Data.TranslateConfig.Source.ParatextId
                    );
                    if (!string.IsNullOrWhiteSpace(writingSystem.Tag))
                    {
                        await projectDoc.SubmitJson0OpAsync(op =>
                            op.Set(p => p.TranslateConfig.Source.WritingSystem.Tag, writingSystem.Tag)
                        );
                    }
                }
            }

            // Clear the existing translation engine id, based on whether this is pre-translation or not
            await projectSecrets.UpdateAsync(
                projectDoc.Id,
                u =>
                {
                    if (preTranslate)
                    {
                        u.Unset(p => p.ServalData.PreTranslationEngineId);
                    }
                    else
                    {
                        u.Unset(p => p.ServalData.TranslationEngineId);
                    }
                }
            );

            // Create the Serval project, and get the translation engine id
            translationEngineId = await CreateServalProjectAsync(projectDoc.Data, preTranslate, cancellationToken);
        }

        // Ensure a translation engine id is present
        if (string.IsNullOrWhiteSpace(translationEngineId))
        {
            throw new DataNotFoundException("Failed to create a translation engine.");
        }

        return translationEngineId;
    }

    /// <summary>
    /// Gets the drafting source language for the project.
    /// </summary>
    /// <param name="project">The project.</param>
    /// <returns>The source language.</returns>
    /// <exception cref="ArgumentNullException">
    /// The writing system tag was not specified for the source project.
    /// </exception>
    /// <exception cref="DataNotFoundException">
    /// The source was not specified for the project, or the project does not exist.
    /// </exception>
    /// <remarks>This can be mocked in unit tests.</remarks>
    protected internal virtual string GetSourceLanguage(SFProject? project)
    {
        // This error can occur if the project is deleted while the build is running
        if (project is null)
        {
            throw new DataNotFoundException("The project does not exist.");
        }

        // This error can occur if the project source is cleared while the build is running
        if (project.TranslateConfig.Source is null)
        {
            throw new DataNotFoundException("The project source is not specified.");
        }

        string alternateSourceLanguage = project.TranslateConfig.DraftConfig.AlternateSource?.WritingSystem.Tag;
        bool useAlternateSourceLanguage =
            project.TranslateConfig.DraftConfig.AlternateSourceEnabled
            && !string.IsNullOrWhiteSpace(alternateSourceLanguage);
        return useAlternateSourceLanguage
            ? alternateSourceLanguage
            : project.TranslateConfig.Source?.WritingSystem.Tag ?? throw new ArgumentNullException(nameof(project));
    }

    /// <summary>
    /// Gets the target language for the project
    /// </summary>
    /// <param name="project">The project.</param>
    /// <returns>The target language.</returns>
    /// <exception cref="ArgumentNullException">
    /// The writing system tag was not specified for the source project.
    /// </exception>
    /// <exception cref="DataNotFoundException">
    /// The source was not specified for the project, or the project does not exist.
    /// </exception>
    /// <remarks>
    /// If Echo is enabled, the source language will be returned.
    /// This can be mocked in unit tests.
    /// </remarks>
    protected internal virtual async Task<string> GetTargetLanguageAsync(SFProject project)
    {
        // Echo requires the target and source language to be the same, as it outputs your source texts
        bool useEcho = await featureManager.IsEnabledAsync(FeatureFlags.UseEchoForPreTranslation);
        return useEcho ? GetSourceLanguage(project) : project.WritingSystem.Tag!;
    }

    /// <summary>
    /// Gets the segments from the text with Unix/Linux line endings.
    /// </summary>
    /// <param name="text">The <see cref="ISFText"/>.</param>
    /// <returns>The text file data to be uploaded to Serval.</returns>
    /// <remarks>This can be mocked in unit tests.</remarks>
    protected internal virtual string GetTextFileData(ISFText text)
    {
        var sb = new StringBuilder();

        // For pre-translation, we must upload empty lines with segment refs for the correct references to be returned
        foreach (SFTextSegment segment in text.Segments.Where(s => !s.IsEmpty))
        {
            sb.Append(segment.SegmentRef);
            sb.Append('\t');
            sb.Append(segment.SegmentText);
            sb.Append('\t');
            if (segment.IsSentenceStart)
            {
                sb.Append("ss,");
            }

            if (segment.IsInRange)
            {
                sb.Append("ir,");
            }

            if (segment.IsRangeStart)
            {
                sb.Append("rs,");
            }

            // Strip the last comma, or the tab if there are no flags
            sb.Length--;

            // Append the Unix EOL to ensure consistency as this text data is uploaded to Serval
            sb.Append('\n');
        }

        return sb.ToString();
    }

    /// <summary>
    /// Gets the TranslationBuildConfig for the specified ServalData object.
    /// </summary>
    /// <param name="servalData">The Serval data from <see cref="SFProjectSecret"/>.</param>
    /// <param name="servalConfig">
    /// The Serval JSON configuration from <see cref="DraftConfig"/>.
    /// </param>
    /// <param name="buildConfig">The build configuration from the user, specified on the front end.</param>
    /// <param name="corporaSyncInfo">The synchronization information for the corpora.</param>
    /// <returns>The TranslationBuildConfig for a Pre-Translate build.</returns>
    /// <remarks>
    /// Do not use with SMT builds.
    /// This can be mocked in unit tests.
    /// </remarks>
    protected internal virtual TranslationBuildConfig GetTranslationBuildConfig(
        ServalData servalData,
        string? servalConfig,
        BuildConfig buildConfig,
        IList<ServalCorpusSyncInfo> corporaSyncInfo
    )
    {
        // Load the Serval Config from the Draft Config
        JObject? options = null;
        if (!string.IsNullOrWhiteSpace(servalConfig))
        {
            options = JObject.Parse(servalConfig);
        }

        // If Fast Training is enabled, override the max_steps
        if (buildConfig.FastTraining)
        {
            // Ensure that there is a servalConfig JSON object
            options ??= [];

            // 20 is the number of steps used on Serval QA by default
            options["max_steps"] = 20;
        }

        // Get the scripture ranges
        // These scripture ranges will be used if no per project configuration was used
        string? trainOnScriptureRange = !string.IsNullOrWhiteSpace(buildConfig.TrainingScriptureRange)
            ? buildConfig.TrainingScriptureRange
            : string.Join(';', buildConfig.TrainingBooks.Select(Canon.BookNumberToId));
        if (string.IsNullOrWhiteSpace(trainOnScriptureRange))
        {
            trainOnScriptureRange = null;
        }

        string? preTranslateScriptureRange = !string.IsNullOrWhiteSpace(buildConfig.TranslationScriptureRange)
            ? buildConfig.TranslationScriptureRange
            : string.Join(';', buildConfig.TranslationBooks.Select(Canon.BookNumberToId));
        if (string.IsNullOrWhiteSpace(preTranslateScriptureRange))
        {
            preTranslateScriptureRange = null;
        }

        // Create the build configuration
        var translationBuildConfig = new TranslationBuildConfig
        {
            Options = options,
            Pretranslate =
            [
                new PretranslateCorpusConfig
                {
                    ParallelCorpusId = servalData.ParallelCorpusIdForPreTranslate,
                    SourceFilters =
                    [
                        .. corporaSyncInfo
                            .Where(s => s.ParallelCorpusId == servalData.ParallelCorpusIdForPreTranslate && s.IsSource)
                            .Select(s => new ParallelCorpusFilterConfig
                            {
                                CorpusId = s.CorpusId,
                                ScriptureRange =
                                    buildConfig
                                        .TranslationScriptureRanges.FirstOrDefault(t => t.ProjectId == s.ProjectId)
                                        ?.ScriptureRange ?? preTranslateScriptureRange,
                            }),
                    ],
                },
            ],
            TrainOn =
            [
                new TrainingCorpusConfig
                {
                    ParallelCorpusId = servalData.ParallelCorpusIdForTrainOn,
                    SourceFilters =
                    [
                        .. corporaSyncInfo
                            .Where(s => s.ParallelCorpusId == servalData.ParallelCorpusIdForTrainOn && s.IsSource)
                            .Select(s => new ParallelCorpusFilterConfig
                            {
                                CorpusId = s.CorpusId,
                                ScriptureRange =
                                    buildConfig
                                        .TrainingScriptureRanges.FirstOrDefault(t => t.ProjectId == s.ProjectId)
                                        ?.ScriptureRange ?? trainOnScriptureRange,
                            }),
                    ],
                    TargetFilters =
                    [
                        .. corporaSyncInfo
                            .Where(s => s.ParallelCorpusId == servalData.ParallelCorpusIdForTrainOn && !s.IsSource)
                            .Select(s => new ParallelCorpusFilterConfig
                            {
                                CorpusId = s.CorpusId,
                                ScriptureRange =
                                    buildConfig
                                        .TrainingScriptureRanges.FirstOrDefault(t => t.ProjectId == s.ProjectId)
                                        ?.ScriptureRange ?? trainOnScriptureRange,
                            }),
                    ],
                },
            ],
        };

        // Add the additional training data
        if (
            !string.IsNullOrWhiteSpace(servalData.AdditionalTrainingData?.ParallelCorpusId)
            && buildConfig.TrainingDataFiles.Count > 0
        )
        {
            translationBuildConfig.TrainOn.Add(
                new TrainingCorpusConfig { ParallelCorpusId = servalData.AdditionalTrainingData.ParallelCorpusId }
            );
        }

        return translationBuildConfig;
    }

    /// <summary>
    /// Recreates the translation engine if the source or target language has changed.
    /// </summary>
    /// <param name="translationEngineId">The translation engine identifier.</param>
    /// <param name="project">The project.</param>
    /// <param name="preTranslate">If <c>true</c> use NMT; otherwise if <c>false</c> use SMT.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>An asynchronous task.</returns>
    /// <remarks>This can be mocked in unit tests.</remarks>
    protected internal virtual async Task RecreateTranslationEngineIfRequiredAsync(
        string translationEngineId,
        SFProject project,
        bool preTranslate,
        CancellationToken cancellationToken
    )
    {
        // Get the translation engine from Serval
        try
        {
            TranslationEngine translationEngine = await translationEnginesClient.GetAsync(
                translationEngineId,
                cancellationToken
            );
            bool recreateTranslationEngine = false;

            // See if the target language has changed
            string projectTargetLanguage = await GetTargetLanguageAsync(project);
            if (translationEngine.TargetLanguage != projectTargetLanguage)
            {
                string message =
                    $"Target language has changed from {translationEngine.TargetLanguage} to {projectTargetLanguage}.";
                logger.LogInformation(message);
                recreateTranslationEngine = true;
            }

            // See if the source language has changed
            string projectSourceLanguage = GetSourceLanguage(project);
            if (translationEngine.SourceLanguage != projectSourceLanguage)
            {
                string message =
                    $"Source language has changed from {translationEngine.SourceLanguage} to {projectSourceLanguage}.";
                logger.LogInformation(message);
                recreateTranslationEngine = true;
            }

            // Delete then recreate the translation engine if they have changed
            if (recreateTranslationEngine)
            {
                // Removal can be a slow process
                await RemoveProjectAsync(project.Id, preTranslate, cancellationToken);
                await CreateServalProjectAsync(project, preTranslate, cancellationToken);
            }
        }
        catch (ServalApiException e) when (e.StatusCode == StatusCodes.Status404NotFound)
        {
            // A 404 means that the translation engine does not exist
            logger.LogInformation(e, $"Translation Engine {translationEngineId} does not exist.");

            // Clear the existing translation engine id and corpora
            await projectSecrets.UpdateAsync(
                project.Id,
                u =>
                {
                    if (preTranslate)
                    {
                        u.Unset(p => p.ServalData.PreTranslationEngineId);
                    }
                    else
                    {
                        u.Unset(p => p.ServalData.TranslationEngineId);
                    }
                }
            );

            // Create the new translation engine id
            translationEngineId = await CreateServalProjectAsync(project, preTranslate, cancellationToken);
            logger.LogInformation($"Created Translation Engine {translationEngineId}.");
        }
    }

    /// <summary>
    /// Removes the legacy files and corpora from Serval.
    /// </summary>
    /// <param name="sfProjectId">The Scripture Forge project identifier.</param>
    /// <param name="preTranslate">If <c>true</c> use NMT; otherwise if <c>false</c> use SMT.</param>
    /// <param name="cancellationToken">The Cancellation token</param>
    /// <returns>An asynchronous task.</returns>
    /// <exception cref="DataNotFoundException">The project secret cannot be found.</exception>
    /// <remarks>This can be mocked in unit tests.</remarks>
    protected internal virtual async Task RemoveLegacyServalDataAsync(
        string sfProjectId,
        bool preTranslate,
        CancellationToken cancellationToken
    )
    {
        // Load the target project secrets, so we can get the translation engine ID
        if (!(await projectSecrets.TryGetAsync(sfProjectId)).TryResult(out SFProjectSecret projectSecret))
        {
            throw new DataNotFoundException("The project secret cannot be found.");
        }

        // Ensure we have a translation engine id
        string translationEngineId = GetTranslationEngineId(projectSecret, preTranslate);
        if (string.IsNullOrWhiteSpace(translationEngineId))
        {
            logger.LogInformation($"No Translation Engine Id specified for project {sfProjectId.Sanitize()}");
            return;
        }

        // Remove the corpora and files
        string[] corpusIds =
            projectSecret
                .ServalData?.Corpora?.Where(c => c.Value.PreTranslate == preTranslate)
                .Select(c => c.Key)
                .ToArray() ?? [];
        foreach (string corpusId in corpusIds)
        {
            // Delete the corpus
            try
            {
                await translationEnginesClient.DeleteCorpusAsync(
                    translationEngineId,
                    corpusId,
                    deleteFiles: true,
                    cancellationToken
                );
            }
            catch (ServalApiException e)
            {
                // A 404 means that the translation engine does not exist
                string message;
                if (e.StatusCode == StatusCodes.Status404NotFound)
                {
                    message =
                        $"Translation Engine {translationEngineId.Sanitize()} for project {sfProjectId.Sanitize()}"
                        + " was missing or already deleted.";
                    logger.LogInformation(message);
                }
                else
                {
                    message =
                        $"Ignored exception while deleting translation engine {translationEngineId.Sanitize()}"
                        + " for project {sfProjectId.Sanitize()}.";
                    logger.LogError(e, message);
                }
            }

            // Remove our record of the corpus
            await projectSecrets.UpdateAsync(sfProjectId, u => u.Unset(p => p.ServalData.Corpora[corpusId]));
        }

        // Remove the corpora property if it is empty
        if (projectSecret.ServalData?.Corpora?.Any(c => c.Value.PreTranslate != preTranslate) == false)
        {
            await projectSecrets.UpdateAsync(sfProjectId, u => u.Unset(p => p.ServalData.Corpora));
        }
    }

    /// <summary>
    /// Synchronizes the additional training data for a pre-translation project.
    /// </summary>
    /// <param name="userAccessor">An IUserAccessor for the acting user.</param>
    /// <param name="project">The project.</param>
    /// <param name="translationEngineId">The translation engine identifier.</param>
    /// <param name="buildConfig">The build configuration from the user.</param>
    /// <param name="additionalTrainingData">The additional training data.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>The updated <paramref name="additionalTrainingData"/>.</returns>
    /// <remarks>
    /// If there are no TrainingDataFiles specified in <paramref name="buildConfig"/>, then the additional training
    /// data corpora will be removed from Serval. Otherwise, the corpora will be created or updated as required.
    /// This can be mocked in unit tests.
    /// </remarks>
    protected internal virtual async Task<ServalAdditionalTrainingData?> SyncAdditionalTrainingData(
        IUserAccessor userAccessor,
        SFProject project,
        string translationEngineId,
        BuildConfig buildConfig,
        ServalAdditionalTrainingData? additionalTrainingData,
        CancellationToken cancellationToken
    )
    {
        // If there are training data files
        if (buildConfig.TrainingDataFiles.Count > 0)
        {
            // Get the training data texts
            List<ISFText> sourceTexts = [];
            List<ISFText> targetTexts = [];
            await trainingDataService.GetTextsAsync(
                userAccessor,
                project.Id,
                buildConfig.TrainingDataFiles,
                sourceTexts,
                targetTexts
            );

            // Create the additional training data object if it is missing
            additionalTrainingData ??= new ServalAdditionalTrainingData();

            // Upload the target texts
            List<ServalCorpusFile> targetCorpusFiles = [.. additionalTrainingData.CorpusFiles];
            additionalTrainingData.TargetCorpusId = await UploadAdditionalTrainingDataAsync(
                project.Id,
                additionalTrainingData.TargetCorpusId,
                languageCode: await GetTargetLanguageAsync(project),
                targetCorpusFiles,
                targetTexts,
                cancellationToken
            );

            // Upload the source texts
            List<ServalCorpusFile> sourceCorpusFiles = [.. additionalTrainingData.CorpusFiles];
            additionalTrainingData.SourceCorpusId = await UploadAdditionalTrainingDataAsync(
                project.Id,
                additionalTrainingData.SourceCorpusId,
                GetSourceLanguage(project),
                sourceCorpusFiles,
                sourceTexts,
                cancellationToken
            );

            // Update the project corpora with the new files
            additionalTrainingData.CorpusFiles = [.. targetCorpusFiles.Union(sourceCorpusFiles)];
            foreach (var corpus in additionalTrainingData.CorpusFiles.GroupBy(c => c.CorpusId))
            {
                await corporaClient.UpdateAsync(
                    corpus.Key,
                    files: [.. corpus.Select(f => new CorpusFileConfig { FileId = f.FileId, TextId = f.TextId })],
                    cancellationToken
                );
            }

            // Set up the parallel corpus for additional training data
            List<string> sourceCorpusIds = [additionalTrainingData.SourceCorpusId];
            List<string> targetCorpusIds = [additionalTrainingData.TargetCorpusId];

            // Create or update the additional training data parallel corpora
            additionalTrainingData.ParallelCorpusId = await CreateOrUpdateParallelCorpusAsync(
                translationEngineId,
                additionalTrainingData.ParallelCorpusId,
                name: "AdditionalTrainingData",
                sourceCorpusIds,
                targetCorpusIds,
                cancellationToken
            );
        }
        else if (additionalTrainingData is not null)
        {
            // Remove the parallel corpora
            if (!string.IsNullOrWhiteSpace(additionalTrainingData.ParallelCorpusId))
            {
                try
                {
                    await translationEnginesClient.DeleteParallelCorpusAsync(
                        translationEngineId,
                        additionalTrainingData.ParallelCorpusId,
                        cancellationToken
                    );
                }
                catch (ServalApiException e) when (e.StatusCode == StatusCodes.Status404NotFound)
                {
                    // If the parallel corpus was already deleted, just log a message
                    string message =
                        $"Parallel Corpus {additionalTrainingData.ParallelCorpusId.Sanitize()}"
                        + $" in project {project.Id.Sanitize()} was missing or already deleted.";
                    logger.LogInformation(e, message);
                }
            }

            // Remove the corpora and files
            await DeleteAllCorporaAndFilesAsync(additionalTrainingData.CorpusFiles, project.Id, cancellationToken);

            // Remove reference to the additional training data from the project secrets
            additionalTrainingData = null;
        }

        return additionalTrainingData;
    }

    /// <summary>
    /// Synchronizes the corpora and files with Serval.
    /// </summary>
    /// <param name="userAccessor">An IUserAccessor for the acting user.</param>
    /// <param name="buildConfig">The build configuration from the user.</param>
    /// <param name="preTranslate">If <c>true</c> use NMT; otherwise if <c>false</c> use SMT.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>
    /// The <see cref="ServalCorpusSyncInfo"/> for all source and target corpora that were synchronised,
    /// excluding the additional data corpora.
    /// </returns>
    /// <exception cref="DataNotFoundException">
    /// The project, project source, or project secret could not be found.
    /// </exception>
    /// <remarks>This can be mocked in unit tests.</remarks>
    protected internal virtual async Task<IList<ServalCorpusSyncInfo>> SyncProjectCorporaAsync(
        IUserAccessor userAccessor,
        BuildConfig buildConfig,
        bool preTranslate,
        CancellationToken cancellationToken
    )
    {
        // Load the project from the realtime service
        Attempt<SFProject> attempt = await realtimeService.TryGetSnapshotAsync<SFProject>(buildConfig.ProjectId);
        if (!attempt.TryResult(out SFProject project))
        {
            throw new DataNotFoundException("The project does not exist.");
        }

        // Ensure we have a source
        if (project.TranslateConfig.Source is null)
        {
            throw new DataNotFoundException("The project source is not specified.");
        }

        // Load the project secrets, so we can get the corpus files
        if (!(await projectSecrets.TryGetAsync(project.Id)).TryResult(out SFProjectSecret projectSecret))
        {
            throw new DataNotFoundException("The project secret cannot be found.");
        }

        // Ensure we have serval data
        if (projectSecret.ServalData is null)
        {
            throw new DataNotFoundException("The Serval data cannot be found.");
        }

        // Return sync information so the translation build configuration can be generated
        List<ServalCorpusSyncInfo> corporaSyncInfo = [];

        // Ensure we have a translation engine ID
        string translationEngineId = GetTranslationEngineId(projectSecret, preTranslate);
        if (string.IsNullOrWhiteSpace(translationEngineId))
        {
            throw new DataNotFoundException("The translation engine ID cannot be found.");
        }

        // See if there is an alternate source to use for drafting
        bool hasAlternateSource =
            project.TranslateConfig.DraftConfig.AlternateSourceEnabled
            && project.TranslateConfig.DraftConfig.AlternateSource is not null
            && project.TranslateConfig.PreTranslate;

        // See if there is an alternate training source corpus
        bool hasAlternateTrainingSource =
            project.TranslateConfig.DraftConfig.AlternateTrainingSourceEnabled
            && project.TranslateConfig.DraftConfig.AlternateTrainingSource is not null
            && project.TranslateConfig.PreTranslate;

        // See if there is an additional training source
        bool hasAdditionalTrainingSource =
            project.TranslateConfig.DraftConfig.AdditionalTrainingSourceEnabled
            && project.TranslateConfig.DraftConfig.AdditionalTrainingSource is not null
            && project.TranslateConfig.PreTranslate;

        // Build the list of corpora and files to upload
        List<(string projectId, string paratextId, string writingSystemTag)> projects =
        [
            // Target Project
            (project.Id, project.ParatextId, project.WritingSystem.Tag),
            // Source Project
            (
                project.TranslateConfig.Source.ProjectRef,
                project.TranslateConfig.Source.ParatextId,
                project.TranslateConfig.Source.WritingSystem.Tag
            ),
        ];
        if (hasAlternateSource)
        {
            projects.Add(
                (
                    project.TranslateConfig.DraftConfig.AlternateSource.ProjectRef,
                    project.TranslateConfig.DraftConfig.AlternateSource.ParatextId,
                    project.TranslateConfig.DraftConfig.AlternateSource.WritingSystem.Tag
                )
            );
        }

        if (hasAlternateTrainingSource)
        {
            projects.Add(
                (
                    project.TranslateConfig.DraftConfig.AlternateTrainingSource.ProjectRef,
                    project.TranslateConfig.DraftConfig.AlternateTrainingSource.ParatextId,
                    project.TranslateConfig.DraftConfig.AlternateTrainingSource.WritingSystem.Tag
                )
            );
        }

        if (hasAdditionalTrainingSource)
        {
            projects.Add(
                (
                    project.TranslateConfig.DraftConfig.AdditionalTrainingSource.ProjectRef,
                    project.TranslateConfig.DraftConfig.AdditionalTrainingSource.ParatextId,
                    project.TranslateConfig.DraftConfig.AdditionalTrainingSource.WritingSystem.Tag
                )
            );
        }

        // Create and upload the Serval Corpus Files
        List<ServalCorpusFile> servalCorpusFiles = [];
        foreach ((string projectId, string paratextId, string languageCode) in projects)
        {
            if (servalCorpusFiles.Any(f => f.ProjectId == projectId))
            {
                // Do not allow duplicate corpora for the same project
                continue;
            }

            ServalCorpusFile servalCorpusFile = projectSecret.ServalData.CorpusFiles.SingleOrDefault(f =>
                f.ProjectId == projectId
            );

            // Ensure that the corpus exists - if it does not, corpusId will be null
            string corpusId = await GetCorpusIdFromServalAsync(servalCorpusFile?.CorpusId, cancellationToken);
            bool isCorpusMissing = servalCorpusFile is null || string.IsNullOrWhiteSpace(corpusId);
            if (isCorpusMissing || servalCorpusFile.LanguageCode != languageCode)
            {
                // Create the corpus if it does not exist or the language code has changed
                Corpus corpus = await corporaClient.CreateAsync(
                    new CorpusConfig { Name = $"{project.Id}_{projectId}", Language = languageCode },
                    cancellationToken
                );
                servalCorpusFile = new ServalCorpusFile
                {
                    CorpusId = corpus.Id,
                    LanguageCode = languageCode,
                    ProjectId = projectId,
                    TextId = project.Id,
                };
            }

            // Upload the file
            await UploadParatextFileAsync(servalCorpusFile, paratextId, cancellationToken);
            servalCorpusFiles.Add(servalCorpusFile);
        }

        // Update the project corpora with the files
        foreach (ServalCorpusFile servalCorpusFile in servalCorpusFiles)
        {
            await corporaClient.UpdateAsync(
                servalCorpusFile.CorpusId,
                files: [new CorpusFileConfig { FileId = servalCorpusFile.FileId, TextId = servalCorpusFile.TextId }],
                cancellationToken
            );
        }

        // Get the source project for the NMT/SMT translation corpus
        string sourceProjectId =
            hasAlternateSource && preTranslate
                ? project.TranslateConfig.DraftConfig.AlternateSource.ProjectRef
                : project.TranslateConfig.Source.ProjectRef;

        // Set up the parallel corpus for NMT/SMT translation
        List<ServalCorpusFile> sourceCorpora = [servalCorpusFiles.Single(f => f.ProjectId == sourceProjectId)];
        List<ServalCorpusFile> targetCorpora = [servalCorpusFiles.Single(f => f.ProjectId == project.Id)];
        List<string> sourceCorpusIds = [.. sourceCorpora.Select(f => f.CorpusId)];
        List<string> targetCorpusIds = [.. targetCorpora.Select(f => f.CorpusId)];

        // Get the NMT/SMT translation parallel corpus id (might be null)
        string translationParallelCorpusId = preTranslate
            ? projectSecret.ServalData.ParallelCorpusIdForPreTranslate
            : projectSecret.ServalData.ParallelCorpusIdForSmt;

        // Create or update the NMT/SMT translation parallel corpora
        translationParallelCorpusId = await CreateOrUpdateParallelCorpusAsync(
            translationEngineId,
            translationParallelCorpusId,
            name: preTranslate ? "PreTranslation" : "SmtTranslation",
            sourceCorpusIds,
            targetCorpusIds,
            cancellationToken
        );

        // Record the corpus sync info for the pre-translate corpora
        corporaSyncInfo = RecordServalCorpusSyncInfo(
            corporaSyncInfo,
            sourceCorpora,
            targetCorpora,
            translationParallelCorpusId
        );

        // If we are NMT pre-translating, add the training parallel corpus
        string trainOnParallelCorpusId = null;
        ServalAdditionalTrainingData? additionalTrainingData = projectSecret.ServalData.AdditionalTrainingData;
        if (preTranslate)
        {
            // Build the source corpus ids for training
            sourceProjectId = hasAlternateTrainingSource
                ? project.TranslateConfig.DraftConfig.AlternateTrainingSource.ProjectRef
                : project.TranslateConfig.Source.ProjectRef;

            sourceCorpora = [servalCorpusFiles.Single(f => f.ProjectId == sourceProjectId)];

            // Add the additional training source, if present and we are pre-translating
            if (hasAdditionalTrainingSource)
            {
                string additionalTrainingSourceProjectId = project
                    .TranslateConfig
                    .DraftConfig
                    .AdditionalTrainingSource
                    .ProjectRef;
                sourceCorpora.Add(servalCorpusFiles.Single(f => f.ProjectId == additionalTrainingSourceProjectId));
            }

            sourceCorpusIds = [.. sourceCorpora.Select(f => f.CorpusId)];

            // Build the target corpus ids for training
            targetCorpora = [servalCorpusFiles.Single(f => f.ProjectId == project.Id)];
            targetCorpusIds = [.. targetCorpora.Select(f => f.CorpusId)];

            // Get the train on parallel corpus id (might be null)
            trainOnParallelCorpusId = projectSecret.ServalData.ParallelCorpusIdForTrainOn;

            // Create or update the train on parallel corpora
            trainOnParallelCorpusId = await CreateOrUpdateParallelCorpusAsync(
                translationEngineId,
                trainOnParallelCorpusId,
                name: "TrainOn",
                sourceCorpusIds,
                targetCorpusIds,
                cancellationToken
            );

            // Record the corpus sync info for the train on corpora
            corporaSyncInfo = RecordServalCorpusSyncInfo(
                corporaSyncInfo,
                sourceCorpora,
                targetCorpora,
                trainOnParallelCorpusId
            );

            // Sync the additional training data
            // NOTE: We do not record the corpus sync info for the additional training data
            // You can get that information from ServalData.AdditionalTrainingData
            additionalTrainingData = await SyncAdditionalTrainingData(
                userAccessor,
                project,
                translationEngineId,
                buildConfig,
                additionalTrainingData,
                cancellationToken
            );
        }

        // Delete any project corpora and files that are no longer used
        await DeleteAllCorporaAndFilesAsync(
            projectSecret.ServalData.CorpusFiles.Except(servalCorpusFiles),
            project.Id,
            cancellationToken
        );

        // Update the project secret
        await projectSecrets.UpdateAsync(
            projectSecret,
            u =>
            {
                u.Set(p => p.ServalData.CorpusFiles, servalCorpusFiles);
                if (preTranslate)
                {
                    u.Set(p => p.ServalData.ParallelCorpusIdForPreTranslate, translationParallelCorpusId);
                    u.Set(p => p.ServalData.ParallelCorpusIdForTrainOn, trainOnParallelCorpusId);
                    u.Set(p => p.ServalData.AdditionalTrainingData, additionalTrainingData);
                }
                else
                {
                    u.Set(p => p.ServalData.ParallelCorpusIdForSmt, translationParallelCorpusId);
                }
            }
        );

        return corporaSyncInfo;
    }

    /// <summary>
    /// Determines whether the specified corpus exists on Serval, and we have access to it returns the identifier.
    /// </summary>
    /// <param name="corpusId">The corpus identifier.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>The corpus identifier if it exists; otherwise <c>null</c>.</returns>
    protected internal virtual async Task<string?> GetCorpusIdFromServalAsync(
        string? corpusId,
        CancellationToken cancellationToken
    )
    {
        // Null or blank identifiers do not exist
        if (string.IsNullOrWhiteSpace(corpusId))
        {
            return null;
        }

        try
        {
            // Check that the corpus exists on Serval, and we have access to it
            Corpus corpus = await corporaClient.GetAsync(corpusId, cancellationToken);
            return corpus.Id;
        }
        catch (ServalApiException e) when (e.StatusCode == StatusCodes.Status404NotFound)
        {
            // The corpus does not exist
            return null;
        }
    }

    /// <summary>
    /// Determines whether a translation engine exists for the specified project.
    /// </summary>
    /// <param name="projectId">The Scripture Forge project identifier.</param>
    /// <param name="translationEngineId">The Serval translation engine identifier.</param>
    /// <param name="preTranslate">If <c>true</c> use NMT; otherwise if <c>false</c> use SMT.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns><c>true</c> if the translation engine exists; otherwise <c>false</c>.</returns>
    /// <remarks>This can be mocked in unit tests.</remarks>
    protected internal virtual async Task<bool> TranslationEngineExistsAsync(
        string projectId,
        string? translationEngineId,
        bool preTranslate,
        CancellationToken cancellationToken
    )
    {
        if (string.IsNullOrWhiteSpace(translationEngineId))
        {
            return false;
        }

        try
        {
            TranslationEngine translationEngine = await translationEnginesClient.GetAsync(
                translationEngineId,
                cancellationToken
            );
            string type = await GetTranslationEngineTypeAsync(preTranslate);

            // We check for the type, taking account of Pascal Case (Serval 1.1) and Kebab Case (Serval 1.2)
            return translationEngine.Name == projectId
                && string.Equals(
                    translationEngine.Type.Replace("-", string.Empty, StringComparison.OrdinalIgnoreCase),
                    type.Replace("-", string.Empty, StringComparison.OrdinalIgnoreCase),
                    StringComparison.InvariantCultureIgnoreCase
                );
        }
        catch (ServalApiException e)
            when (e.StatusCode is StatusCodes.Status403Forbidden or StatusCodes.Status404NotFound)
        {
            return false;
        }
    }

    /// <summary>
    /// Uploads the additional training data for a project.
    /// </summary>
    /// <param name="projectId">The project identifier.</param>
    /// <param name="corpusId">The corpus identifier.</param>
    /// <param name="languageCode">The language for the corpus.</param>
    /// <param name="corpusFiles">The existing corpus files. These will be replaced with the new corpus files.</param>
    /// <param name="texts">The texts to upload.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>The updated corpus identifier.</returns>
    /// <remarks>This can be mocked in unit tests.</remarks>
    protected internal virtual async Task<string> UploadAdditionalTrainingDataAsync(
        string projectId,
        string? corpusId,
        string languageCode,
        List<ServalCorpusFile> corpusFiles,
        List<ISFText> texts,
        CancellationToken cancellationToken
    )
    {
        // Make a local copy of the previous corpus files
        List<ServalCorpusFile> previousCorpusFiles = [.. corpusFiles];
        corpusFiles.Clear();

        // Delete the old corpus if the language has changed
        string corpusLanguageCode = previousCorpusFiles.FirstOrDefault(f => f.CorpusId == corpusId)?.LanguageCode;
        if (
            !string.IsNullOrWhiteSpace(corpusLanguageCode)
            && languageCode != corpusLanguageCode
            && !string.IsNullOrWhiteSpace(corpusId)
        )
        {
            try
            {
                await corporaClient.DeleteAsync(corpusId, cancellationToken);
            }
            catch (ServalApiException e) when (e.StatusCode == StatusCodes.Status404NotFound)
            {
                // If the corpus was already deleted, just log a message
                string message =
                    $"Corpus {corpusId.Sanitize()} in project {projectId.Sanitize()}"
                    + " was missing or already deleted.";
                logger.LogInformation(e, message);
            }
            corpusId = null;
        }

        // Ensure that the corpus exists - if it does not, corpusId will be null
        corpusId = await GetCorpusIdFromServalAsync(corpusId, cancellationToken);

        // If there is no corpus, create it
        if (string.IsNullOrWhiteSpace(corpusId))
        {
            Corpus corpus = await corporaClient.CreateAsync(
                new CorpusConfig
                {
                    Name = $"{projectId}_additionalTrainingData_{languageCode}",
                    Language = languageCode,
                },
                cancellationToken
            );
            corpusId = corpus.Id;
        }

        foreach (ISFText text in texts)
        {
            // The text ids are in the format projectId_dataId
            string textId = text.Id.Split('_').Last();

            // Get the existing Serval Corpus File, or create a new one
            ServalCorpusFile servalCorpusFile =
                previousCorpusFiles.SingleOrDefault(f => f.TextId == textId && f.CorpusId == corpusId)
                ?? new ServalCorpusFile
                {
                    CorpusId = corpusId,
                    LanguageCode = languageCode,
                    ProjectId = projectId,
                    TextId = textId,
                };

            // Upload the text
            if (await UploadTextFileAsync(servalCorpusFile, text, cancellationToken))
            {
                corpusFiles.Add(servalCorpusFile);
            }
        }

        return corpusId;
    }

    /// <summary>
    /// Uploads a file to Serval.
    /// </summary>
    /// <param name="servalCorpusFile">The Serval corpus file</param>
    /// <param name="stream">The stream of file data.</param>
    /// <param name="fileFormat">The Serval file format.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>An asynchronous task.</returns>
    /// <remarks>This can be mocked in unit tests.</remarks>
    protected internal virtual async Task UploadFileAsync(
        ServalCorpusFile servalCorpusFile,
        Stream stream,
        FileFormat fileFormat,
        CancellationToken cancellationToken
    )
    {
        // Reset the stream to the start
        stream.Seek(0, SeekOrigin.Begin);

        // Calculate the checksum from the stream
        using MD5 md5 = MD5.Create();
        StringBuilder sb = new StringBuilder();
        foreach (var hashByte in await md5.ComputeHashAsync(stream, cancellationToken))
        {
            sb.Append(hashByte.ToString("X2").ToLower());
        }

        // See if the file has changed
        string checksum = sb.ToString();
        if (servalCorpusFile.FileChecksum == checksum)
        {
            // No update, so do not upload
            return;
        }

        // Reset the stream to the start
        stream.Seek(0, SeekOrigin.Begin);

        // See if the file exists, and it is the same format
        bool dataFileExists = false;
        if (!string.IsNullOrWhiteSpace(servalCorpusFile.FileId))
        {
            try
            {
                DataFile existingDataFile = await dataFilesClient.GetAsync(servalCorpusFile.FileId, cancellationToken);
                dataFileExists = existingDataFile.Format == fileFormat;

                // Delete the file if we are changing the format
                if (!dataFileExists)
                {
                    logger.LogInformation($"File {servalCorpusFile.FileId} has the wrong format - deleting.");
                    await dataFilesClient.DeleteAsync(servalCorpusFile.FileId, cancellationToken);
                }
            }
            catch (ServalApiException e) when (e.StatusCode == StatusCodes.Status404NotFound)
            {
                logger.LogInformation(e, $"File {servalCorpusFile.FileId} does not exist - creating.");
            }
        }

        // Update the file if it exists, otherwise create it
        DataFile dataFile = dataFileExists
            ? await dataFilesClient.UpdateAsync(servalCorpusFile.FileId, new FileParameter(stream), cancellationToken)
            : await dataFilesClient.CreateAsync(
                new FileParameter(stream),
                fileFormat,
                servalCorpusFile.TextId,
                cancellationToken
            );

        // Update the Serval Corpus File
        servalCorpusFile.FileChecksum = checksum;
        servalCorpusFile.FileId = dataFile.Id;
    }

    /// <summary>
    /// Uploads a Paratext zip file to Serval.
    /// </summary>
    /// <param name="servalCorpusFile">The Serval corpus file</param>
    /// <param name="paratextId">The Paratext identifier.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns>An asynchronous task.</returns>
    /// <remarks>This can be mocked in unit tests.</remarks>
    protected internal virtual async Task UploadParatextFileAsync(
        ServalCorpusFile servalCorpusFile,
        string paratextId,
        CancellationToken cancellationToken
    )
    {
        // Create the zip file from the directory in memory
        await using var stream = new MemoryStream();
        await CreateZipFileFromParatextDirectoryAsync(paratextId, stream, cancellationToken);

        // Upload the zip file
        await UploadFileAsync(servalCorpusFile, stream, FileFormat.Paratext, cancellationToken);
    }

    /// <summary>
    /// Uploads a text file to Serval.
    /// </summary>
    /// <param name="servalCorpusFile">The Serval corpus file</param>
    /// <param name="text">The text.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns><c>true</c> if the file was uploaded; otherwise, <c>false</c>.</returns>
    /// <remarks>This can be mocked in unit tests.</remarks>
    protected internal virtual async Task<bool> UploadTextFileAsync(
        ServalCorpusFile servalCorpusFile,
        ISFText text,
        CancellationToken cancellationToken
    )
    {
        string textFileData = GetTextFileData(text);

        // Ensure that there is file data
        if (string.IsNullOrWhiteSpace(textFileData))
        {
            return false;
        }

        // Upload the text file
        byte[] buffer = Encoding.UTF8.GetBytes(textFileData);
        await using Stream stream = new MemoryStream(buffer, false);
        await UploadFileAsync(servalCorpusFile, stream, FileFormat.Text, cancellationToken);
        return true;
    }

    /// <summary>
    /// Gets the translation engine identifier from the project secret,
    /// depending on whether we are pre-translating or not.
    /// </summary>
    /// <param name="projectSecret">The project secret.</param>
    /// <param name="preTranslate">If <c>true</c>, we are pre-translating.</param>
    /// <returns>The translation engine identifier.</returns>
    private static string? GetTranslationEngineId(SFProjectSecret projectSecret, bool preTranslate) =>
        preTranslate ? projectSecret.ServalData?.PreTranslationEngineId : projectSecret.ServalData?.TranslationEngineId;

    /// <summary>
    /// Records the Corpus Synchronization information.
    /// </summary>
    /// <param name="corpusSyncInfo">The List of corpus synchronization information.</param>
    /// <param name="sourceCorpora">The list of source corpora</param>
    /// <param name="targetCorpora">The list of target corpora.</param>
    /// <param name="parallelCorpusId">The parallel corpus identifier.</param>
    /// <returns><paramref name="corpusSyncInfo"/></returns>
    /// <remarks>Used by <see cref="SyncProjectCorporaAsync"/>.</remarks>
    private static List<ServalCorpusSyncInfo> RecordServalCorpusSyncInfo(
        List<ServalCorpusSyncInfo> corpusSyncInfo,
        IList<ServalCorpusFile> sourceCorpora,
        IList<ServalCorpusFile> targetCorpora,
        string parallelCorpusId
    )
    {
        corpusSyncInfo.AddRange(
            sourceCorpora.Select(f => new ServalCorpusSyncInfo
            {
                CorpusId = f.CorpusId,
                ParallelCorpusId = parallelCorpusId,
                IsSource = true,
                ProjectId = f.ProjectId,
            })
        );
        corpusSyncInfo.AddRange(
            targetCorpora.Select(f => new ServalCorpusSyncInfo
            {
                CorpusId = f.CorpusId,
                ParallelCorpusId = parallelCorpusId,
                IsSource = false,
                ProjectId = f.ProjectId,
            })
        );
        return corpusSyncInfo;
    }
}
